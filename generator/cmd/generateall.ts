// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import * as constants from '../constants';
import { cloneAndGenerateBasePaths, generateBasePaths, getPackageString, resolveAbsolutePath, validateAndReturnReadmePath } from '../specs';
import { SchemaConfiguration, generateSchemas, clearAutoGeneratedSchemaRefs, saveAutoGeneratedSchemaRefs, getApiVersionsByNamespace } from '../generate';
import { findOrGenerateAutogenEntries } from '../autogenlist';
import chalk from 'chalk';
import { flatten, keys } from 'lodash';
import { executeSynchronous, chunker, writeJsonFile } from '../utils';
import { Package } from '../models';
import yargs from 'yargs';

const argsConfig = yargs
  .strict()
  .option('batch-count', { type: 'number', desc: 'If running in batch mode, the total number of batch jobs running' })
  .option('batch-index', { type: 'number', desc: 'If running in batch mode, the index of this batch job' })
  .option('local-path', { type: 'string', desc: 'The local path to the azure-rest-api-specs repo' })
  .option('readme-files', { type: 'array', desc: 'The list of readme.md files to generate schemas for' })
  .option('output-path', { type: 'string', desc: 'The base path to save schema output' });

executeSynchronous(async () => {
    const args = await argsConfig.parseAsync();

    let basePaths;
    let localPath = args['local-path'];
    if (!localPath) {
        localPath = constants.specsRepoPath;
        basePaths = await cloneAndGenerateBasePaths(localPath, constants.specsRepoUri, constants.specsRepoCommitHash);
    } else {
        localPath = await resolveAbsolutePath(localPath);
        basePaths = await generateBasePaths(localPath);
    }

    if (args['batch-count'] !== undefined && args['batch-index'] !== undefined) {
        basePaths = chunker(basePaths, args['batch-count'])[args['batch-index']];
    }

    const schemaConfigs: SchemaConfiguration[] = [];
    const errors = [];
    const packages: Package[] = [];

    for (const basePath of basePaths) {
        const readme = await validateAndReturnReadmePath(localPath, basePath);
        const namespaces = keys(await getApiVersionsByNamespace(readme));
        let filteredAutoGenList = findOrGenerateAutogenEntries(basePath, namespaces)
            .filter(x => x.disabledForAutogen !== true);

        if (args['readme-files']) {
            filteredAutoGenList = filteredAutoGenList.filter(c => {
                const readmeFiles = args['readme-files']?.map(x => x.toString());
                const r = readmeFiles?.find(f => f.startsWith('specification/' + c.basePath));
                if (r) {
                    c.readmeFile = r;
                    return true;
                }
                return false;
            });
        }

        await clearAutoGeneratedSchemaRefs(filteredAutoGenList);

        for (const autoGenConfig of filteredAutoGenList) {
            const pkg = {
                path: ['schemas']
            } as Package;
            try {
                const readme = await validateAndReturnReadmePath(localPath, autoGenConfig.readmeFile || autoGenConfig.basePath);
                pkg.packageName = getPackageString(readme);

                const newConfigs = await generateSchemas(readme, autoGenConfig);
                schemaConfigs.push(...newConfigs);
                pkg.result = 'succeeded';
            } catch(error) {
                pkg.packageName = autoGenConfig.basePath;
                pkg.result = 'failed';
                console.log(chalk.red(`Caught exception processing autogenlist entry ${autoGenConfig.basePath}.`));
                console.log(chalk.red(error));
        
                errors.push(error);
            }
            packages.push(pkg);
        }
    }

    await saveAutoGeneratedSchemaRefs(flatten(schemaConfigs));

    if (args['output-path']) {
        const outputPath = await resolveAbsolutePath(args['output-path']);
        await writeJsonFile(outputPath, { packages });
    } else {
        if (errors.length > 0) {
            throw new Error(`Autogeneration failed with ${errors.length} errors. See logs for detailed information.`);
        }
    }

});
