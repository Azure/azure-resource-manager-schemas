import * as constants from '../constants';
import { cloneAndGenerateBasePaths, getPackageString, resolveAbsolutePath, validateAndReturnReadmePath } from '../specs';
import { SchemaConfiguration, generateSchemas, clearAutogeneratedSchemaRefs, saveAutogeneratedSchemaRefs } from '../generate';
import { getAutogenlist } from '../autogenlist';
import chalk from 'chalk';
import { flatten } from 'lodash';
import { executeSynchronous, chunker, writeJsonFile } from '../utils';
import { Package } from '../models';

interface GenerateAllParams {
    batchCount?: number,
    batchIndex?: number,
    localPath?: string,
    readmeFiles?: string[],
    outputPath?: string,
}

function parseParams(): GenerateAllParams {
    if (!process.argv[2]) {
        return {};
    }

    return JSON.parse(process.argv[2]);
}

executeSynchronous(async () => {
    const params = parseParams();

    let filteredAutogenlist = getAutogenlist();
    if (params.batchCount !== undefined && params.batchIndex !== undefined) {
        filteredAutogenlist = chunker(filteredAutogenlist, params.batchCount)[params.batchIndex];
    }

    let localPath = params.localPath;
    if (!localPath) {
        localPath = constants.specsRepoPath;
        await cloneAndGenerateBasePaths(localPath, constants.specsRepoUri, constants.specsRepoCommitHash);
    } else {
        localPath = await resolveAbsolutePath(localPath);
    }

    if (!!params.readmeFiles) {
        filteredAutogenlist = filteredAutogenlist.filter(c => {
            let r = params.readmeFiles?.find(f => f.startsWith('specification/' + c.basePath));
            if (!!r) {
                c.readmeFile = r;
                return true;
            }
            return false;
        }
        );
    }

    await clearAutogeneratedSchemaRefs(filteredAutogenlist);

    const schemaConfigs: SchemaConfiguration[] = [];
    const errors = [];
    const packages: Package[] = [];
    for (const autogenlistConfig of filteredAutogenlist) {
        let pkg = {} as Package;
        try {
            const readme = await validateAndReturnReadmePath(localPath, autogenlistConfig.readmeFile || autogenlistConfig.basePath);
            pkg.packageName = getPackageString(readme);

            const newConfigs = await generateSchemas(readme, autogenlistConfig);
            schemaConfigs.push(...newConfigs);
            pkg.result = 'succeeded';
        } catch(error) {
            pkg.packageName = autogenlistConfig.basePath;
            pkg.result = 'failed';
            console.log(chalk.red(`Caught exception processing autogenlist entry ${autogenlistConfig.basePath}.`));
            console.log(chalk.red(error));
    
            errors.push(error);
        }
        packages.push(pkg);
    }

    await saveAutogeneratedSchemaRefs(flatten(schemaConfigs));

    if (!!params.outputPath) {
        const outputPath = await resolveAbsolutePath(params.outputPath);
        await writeJsonFile(outputPath, { packages });
    } else {
        if (errors.length > 0) {
            throw new Error(`Autogeneration failed with ${errors.length} errors. See logs for detailed information.`);
        }
    }

});