// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import * as constants from '../constants';
import { cloneAndGenerateBasePaths, generateBasePaths, getPackageString, resolveAbsolutePath, validateAndReturnReadmePath } from '../specs';
import { SchemaConfiguration, generateSchemas, clearAutoGeneratedSchemaRefs, saveAutoGeneratedSchemaRefs, getApiVersionsByNamespace } from '../generate';
import { findOrGenerateAutogenEntries } from '../autogenlist';
import chalk from 'chalk';
import { flatten, keys } from 'lodash';
import { executeSynchronous, chunker, writeJsonFile } from '../utils';
import { Package } from '../models';
import yargs from 'yargs';
import path from 'path/posix';

import { createWriteStream } from 'fs';
import stripAnsi from 'strip-ansi';

const argsConfig = yargs
  .strict()
  .option('batch-count', { type: 'number', desc: 'If running in batch mode, the total number of batch jobs running' })
  .option('batch-index', { type: 'number', desc: 'If running in batch mode, the index of this batch job' })
  .option('local-path', { type: 'string', desc: 'The local path to the azure-rest-api-specs repo' })
  .option('readme-files', { type: 'array', desc: 'The list of readme.md files to generate schemas for' })
  .option('output-path', { type: 'string', desc: 'The base path to save schema output' })
  .option('summary-log-path', { type: 'string', desc: 'The path to store generation summary information. File will be saved in md format.' });

interface ILogger {
    out: (data: string) => void;
}

executeSynchronous(async () => {
    const args = await argsConfig.parseAsync();

    let basePaths;
    let localPath = args['local-path'];
    let summaryPath = args['summary-log-path'];

    if (!localPath) {
        localPath = constants.specsRepoPath;
        basePaths = await cloneAndGenerateBasePaths(localPath, constants.specsRepoUri, constants.specsRepoCommitHash);
    } else {
        localPath = await resolveAbsolutePath(localPath);
        basePaths = await generateBasePaths(localPath);
    }

    if (!summaryPath) {
        // generate default full path
        summaryPath = path.join(constants.specsRepoPath, 'summary.log');
    }

    // resolve absolute path
    summaryPath = await resolveAbsolutePath(summaryPath);

    if (args['batch-count'] !== undefined && args['batch-index'] !== undefined) {
        basePaths = chunker(basePaths, args['batch-count'])[args['batch-index']];
    }

    const schemaConfigs: SchemaConfiguration[] = [];
    const errors = [];
    const packages: Package[] = [];

    const summaryLogger = await getLogger(summaryPath);

    for (const basePath of basePaths) {
        const readme = await validateAndReturnReadmePath(localPath, basePath);
        const namespaces = keys(await getApiVersionsByNamespace(readme));
        let filteredAutoGenList = findOrGenerateAutogenEntries(basePath, namespaces)
            .filter(x => x.disabledForAutogen !== true);

        if (args['readme-files']) {
            filteredAutoGenList = filteredAutoGenList.filter(c => {
                const readmeFiles = args['readme-files']?.map(x => x.toString());
                const r = readmeFiles?.find(f => f.startsWith('specification/' + c.basePath));
                if (r) {
                    c.readmeFile = r;
                    return true;
                }
                return false;
            });
        }

        await clearAutoGeneratedSchemaRefs(filteredAutoGenList);

        for (const autoGenConfig of filteredAutoGenList) {
            const pkg = {
                path: ['schemas']
            } as Package;
            try {
                const readme = await validateAndReturnReadmePath(localPath, autoGenConfig.readmeFile || autoGenConfig.basePath);
                pkg.packageName = getPackageString(readme);

                const newConfigs = await generateSchemas(readme, autoGenConfig);
                schemaConfigs.push(...newConfigs);
                pkg.result = 'succeeded';
            } catch(error) {
                pkg.packageName = autoGenConfig.basePath;
                pkg.result = 'failed';
                console.log(chalk.red(`Caught exception processing autogenlist entry ${autoGenConfig.basePath}.`));
                console.log(chalk.red(error));
        
                // Use markdown formatting as this summary will be included in the PR description
                logOut(summaryLogger, 
                    `<details>
                    <summary>Failed to generate types for path '${basePath}'</summary>
                    \`\`\`
                    ${error}
                    \`\`\`
                    </details>
                    `);
            }
            packages.push(pkg);
        }
    }

    await saveAutoGeneratedSchemaRefs(flatten(schemaConfigs));

    if (args['output-path']) {
        const outputPath = await resolveAbsolutePath(args['output-path']);
        await writeJsonFile(outputPath, { packages });
    }
});

function logOut(logger: ILogger, line: string) {
    logger.out(`${line}\n`);
}
  
async function getLogger(logFilePath: string): Promise<ILogger> {
    const logFileStream = createWriteStream(logFilePath, { flags: 'a' });

    return {
        out: (data: string) => {
            process.stdout.write(data);
            logFileStream.write(stripAnsi(data));
        }
    };
}
