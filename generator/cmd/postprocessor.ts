import path from 'path';
import chalk from 'chalk';
import { executeSynchronous, lowerCaseEquals, safeUnlink } from '../utils';
import { findAutogenEntries } from '../autogenlist';
import { saveAutogeneratedSchemaRefs, SchemaConfiguration, schemaPostProcess } from '../generate';
import * as constants from '../constants';

function getStatus(file: any){
    var status;
    if (file.isNew()) status = 'new';
    else if (file.isModified()) status = 'modified';
    else if (file.isDeleted()) status = 'deleted';
    else if (file.isTypeChange()) status = 'typechange';
    else if (file.isRenamed()) status = 'renamed';
    else if (file.isIgnored()) status = 'ignored';

    return {
        'path': file.path(),
        'status': status
    };
}

async function getChangedSchemas(repoPath: string) {
    var Git = require("nodegit");
    const repo = await Git.Repository.open(repoPath);
    const files = await repo.getStatus();
    let status = [];
    if (files.length) {
        status = files.map(getStatus);
    }
    const changedSchemas: { path: string, isNew: boolean }[] = [];
    for (const stat of status) {
        if (stat.path.toString().split(path.sep).indexOf('schemas') !== -1
            && path.extname(stat.path) === '.json') {
            if (stat.status !== 'modified' && stat.status !== 'new') {
                throw new Error(`Undefined file status for '${stat.path}'.`);
            } else {
                if (stat.status === 'modified') {
                    changedSchemas.push({
                        path: path.join(repoPath, stat.path),
                        isNew: false
                    });
                } else {
                    changedSchemas.push({
                        path: path.join(repoPath, stat.path),
                        isNew: true
                    });
                }
            }
        }
    }
    return changedSchemas;
}

async function postProcessor(basePath: string) {
    const autogenEntries = findAutogenEntries(basePath);
    let changedSchemas = await getChangedSchemas(constants.generatorRoot);
    let schemaConfigs: SchemaConfiguration[] = [];
    for (const changedSchema of changedSchemas) {
        const changedSchemaPath = changedSchema.path;
        console.log('Processing changed schema file: ' + chalk.green(changedSchemaPath));
        const namespace = path.basename(changedSchemaPath.substring(0, changedSchemaPath.lastIndexOf(path.extname(changedSchemaPath))));
        const autogenEntriesSameNamespace = autogenEntries
        .filter(autogenEntry => lowerCaseEquals(autogenEntry.namespace, namespace));
        if (autogenEntriesSameNamespace.length === 0) {
            const localSchemaConfig = await schemaPostProcess(changedSchemaPath, changedSchema.isNew);
            schemaConfigs.push(localSchemaConfig);
        } else {
            if (autogenEntriesSameNamespace.length > 1) {
                throw new Error(`Multiple autogenEntries for '${changedSchemaPath}'`);
            }
            const autogenlistConfig = autogenEntriesSameNamespace[0];
            const localSchemaConfig = await schemaPostProcess(changedSchemaPath, changedSchema.isNew, autogenlistConfig);
            schemaConfigs.push(localSchemaConfig);
        }
    }
    await saveAutogeneratedSchemaRefs(schemaConfigs);
    await safeUnlink(path.join(constants.generatorRoot, "schemas", "code-model-v1"));
}

executeSynchronous(async () => {
    const basePath = process.argv[2];
    try {
        await postProcessor(basePath);
        console.log(`PostProcessor finished successfully.`);
    } catch (e) {
        console.error(`PostProcessor ${e}`);
    }
});
