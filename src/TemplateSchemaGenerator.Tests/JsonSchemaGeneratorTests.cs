// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

using System.Diagnostics.CodeAnalysis;
using System.Text.RegularExpressions;
using System.Text.Json.Nodes;
using Azure.Bicep.Types.Az;
using Azure.Deployments.Testing.Utilities;
using FluentAssertions;

namespace TemplateSchemaGenerator.Tests;

[TestClass]
public class JsonSchemaGeneratorTests
{
    [NotNull]
    public TestContext? TestContext { get; set; }

    [TestMethod]
    [TestCategory(BaselineHelper.BaselineTestCategory)]
    [EmbeddedFilesTestData(@"^Files/schemas/.*\.json$")]
    public void Schema_generation_works(EmbeddedFile embeddedFile)
    {
        var baselineFolder = BaselineFolder.BuildOutputFolder(TestContext, embeddedFile);
        var schemaFile = baselineFolder.GetBaselineFile(embeddedFile.FileName);

        var streamPathParts = embeddedFile.StreamPath.Split('/').Skip(2).ToArray();
        var apiVersion = streamPathParts[0];
        var providerNamespace = string.Join('/', streamPathParts[1..])[..^".json".Length];

        var typeProvider = new ResourceTypeProvider(new AzTypeLoader());
        var resourceTypes = typeProvider.GetResourceTypes()
            .Where(x => string.Equals(Utils.GetProviderNamespace(x.resourceType), providerNamespace, System.StringComparison.OrdinalIgnoreCase))
            .Where(x => string.Equals(x.apiVersion, apiVersion, System.StringComparison.OrdinalIgnoreCase))
            .Select(x => typeProvider.Get(x.resourceType, x.apiVersion))
            .ToArray();

        var schema = JsonSchemaGenerator.GenerateProviderSchema(providerNamespace, apiVersion, resourceTypes);

        schemaFile.WriteToOutputFolder(schema.ToJsonString(MainGenerator.SerializerOptions));
        schemaFile.ShouldHaveExpectedValue();
    }

    [TestMethod]
    [EmbeddedFilesTestData(@"^Files/schemas/.*\.json$")]
    public void Schema_definitions_do_not_contain_ref_cycles(EmbeddedFile embeddedFile)
    {
        var streamPathParts = embeddedFile.StreamPath.Split('/').Skip(2).ToArray();
        var apiVersion = streamPathParts[0];
        var providerNamespace = string.Join('/', streamPathParts[1..])[..^".json".Length];

        var typeProvider = new ResourceTypeProvider(new AzTypeLoader());
        var resourceTypes = typeProvider.GetResourceTypes()
            .Where(x => string.Equals(Utils.GetProviderNamespace(x.resourceType), providerNamespace, System.StringComparison.OrdinalIgnoreCase))
            .Where(x => string.Equals(x.apiVersion, apiVersion, System.StringComparison.OrdinalIgnoreCase))
            .Select(x => typeProvider.Get(x.resourceType, x.apiVersion))
            .ToArray();

        var schema = JsonSchemaGenerator.GenerateProviderSchema(providerNamespace, apiVersion, resourceTypes);
        var root = schema;

        if (root["definitions"] is not JsonObject definitions)
        {
            return;
        }

        var edgesByDefinition = new Dictionary<string, HashSet<string>>(System.StringComparer.OrdinalIgnoreCase);
        foreach (var (definitionName, definitionSchema) in definitions)
        {
            var edges = new HashSet<string>(System.StringComparer.OrdinalIgnoreCase);
            foreach (var target in EnumerateLocalDefinitionRefs(definitionSchema))
            {
                edges.Add(target);
            }
            edgesByDefinition[definitionName] = edges;
        }

        var cycles = FindCycles(edgesByDefinition)
            .Select(cycle => string.Join(" -> ", cycle))
            .ToArray();

        cycles.Should().BeEmpty(
            "schema definitions should not contain $ref cycles (provider={0}, apiVersion={1})\nDetected cycles:\n{2}",
            providerNamespace,
            apiVersion,
            string.Join("\n", cycles));
    }

    [TestMethod]
    [TestCategory(BaselineHelper.BaselineTestCategory)]
    [EmbeddedFilesTestData(@"^Files/common/autogeneratedResources\.json$")]
    public void Autogenerated_resources_works(EmbeddedFile embeddedFile)
    {
        var baselineFolder = BaselineFolder.BuildOutputFolder(TestContext, embeddedFile);
        var schemaFile = baselineFolder.GetBaselineFile(embeddedFile.FileName);

        var typeProvider = new ResourceTypeProvider(new AzTypeLoader());

        var providerBaselineRegex = new Regex(@"^Files/schemas/\d{4}-\d{2}-\d{2}(?:-(?:preview|privatepreview))?/.*\.json$", RegexOptions.Compiled);
        var embeddedProviders = GetType().Assembly
            .GetManifestResourceNames()
            .Where(name => providerBaselineRegex.IsMatch(name))
            .Select(name => name.Split('/').Skip(2).ToArray())
            .Select(parts => (
                apiVersion: parts[0],
                providerNamespace: string.Join('/', parts[1..])[..^".json".Length]))
            .Distinct()
            .ToArray();

        var refs = new List<AutogeneratedResourcesGenerator.ResourceRef>();

        foreach (var (apiVersion, providerNamespace) in embeddedProviders)
        {
            var resourceTypes = typeProvider.GetResourceTypes()
                .Where(x => string.Equals(Utils.GetProviderNamespace(x.resourceType), providerNamespace, System.StringComparison.OrdinalIgnoreCase))
                .Where(x => string.Equals(x.apiVersion, apiVersion, System.StringComparison.OrdinalIgnoreCase))
                .Select(x => typeProvider.Get(x.resourceType, x.apiVersion))
                .ToArray();

            foreach (var resourceType in resourceTypes)
            {
                var resourceTypeName = resourceType.Name.Split('@', 2)[0];
                var key = JsonSchemaGenerator.GetArmResourceDefinitionKey(resourceTypeName);

                refs.Add(new(apiVersion, providerNamespace, resourceType, key));
            }
        }

        var content = AutogeneratedResourcesGenerator.Generate([..refs]);
        schemaFile.WriteToOutputFolder(content.ToJsonString(MainGenerator.SerializerOptions));
        schemaFile.ShouldHaveExpectedValue();
    }

    [TestMethod]
    public void GetArmResourceDefinitionKey_sanitizes_unsafe_characters()
    {
        // Example: nested resource type segment contains '.' which breaks schema normalization if emitted into a definition key.
        var key = JsonSchemaGenerator.GetArmResourceDefinitionKey("Microsoft.Billing/billingPeriods/Microsoft.Consumption");

        Assert.AreEqual("billingPeriods_Microsoft_Consumption", key);
    }

    [TestMethod]
    public void Schema_generation_does_not_emit_Type_or_ApiVersion_case_variants()
    {
        var typeProvider = new ResourceTypeProvider(new AzTypeLoader());
        var resourceTypes = typeProvider.GetResourceTypes()
            .Where(x => string.Equals(Utils.GetProviderNamespace(x.resourceType), "Microsoft.Insights", System.StringComparison.OrdinalIgnoreCase))
            .Where(x => string.Equals(x.apiVersion, "2015-05-01", System.StringComparison.OrdinalIgnoreCase))
            .Select(x => typeProvider.Get(x.resourceType, x.apiVersion))
            .ToArray();

        var schema = JsonSchemaGenerator.GenerateProviderSchema("Microsoft.Insights", "2015-05-01", resourceTypes);
        var root = schema;

        var resourceDefinitions = root["resourceDefinitions"]!.AsObject();
        // This is one of the entries that historically had both "type" and "Type".
        var analyticsItems = resourceDefinitions["components_analyticsItems"]!.AsObject();
        var props = analyticsItems["properties"]!.AsObject();

        Assert.IsFalse(props.ContainsKey("Type"), "Should not emit 'Type' alongside reserved 'type'.");
        Assert.IsFalse(props.ContainsKey("ApiVersion"), "Should not emit 'ApiVersion' alongside reserved 'apiVersion'.");
    }

    private static IEnumerable<string> EnumerateLocalDefinitionRefs(JsonNode? node)
    {
        if (node is null)
        {
            yield break;
        }

        if (node is JsonObject obj)
        {
            if (obj.TryGetPropertyValue("$ref", out var refNode) && refNode is JsonValue refValue)
            {
                var refString = refValue.GetValue<string>();
                const string prefix = "#/definitions/";
                if (refString.StartsWith(prefix, System.StringComparison.OrdinalIgnoreCase))
                {
                    yield return refString[prefix.Length..];
                }
            }

            foreach (var child in obj.Select(kvp => kvp.Value))
            {
                foreach (var r in EnumerateLocalDefinitionRefs(child))
                {
                    yield return r;
                }
            }

            yield break;
        }

        if (node is JsonArray arr)
        {
            foreach (var child in arr)
            {
                foreach (var r in EnumerateLocalDefinitionRefs(child))
                {
                    yield return r;
                }
            }
        }
    }

    private static IEnumerable<IReadOnlyList<string>> FindCycles(IReadOnlyDictionary<string, HashSet<string>> edgesByDefinition)
    {
        var visited = new HashSet<string>(System.StringComparer.OrdinalIgnoreCase);
        var stack = new Stack<string>();
        var onStack = new HashSet<string>(System.StringComparer.OrdinalIgnoreCase);
        var cycles = new List<IReadOnlyList<string>>();

        foreach (var start in edgesByDefinition.Keys)
        {
            if (!visited.Contains(start))
            {
                Dfs(start);
            }
        }

        return cycles;

        void Dfs(string node)
        {
            visited.Add(node);
            stack.Push(node);
            onStack.Add(node);

            if (edgesByDefinition.TryGetValue(node, out var edges))
            {
                foreach (var next in edges)
                {
                    if (!visited.Contains(next))
                    {
                        Dfs(next);
                        continue;
                    }

                    if (onStack.Contains(next))
                    {
                        // Materialize cycle path from 'next' up to current node.
                        var cycle = stack.Reverse().SkipWhile(x => !string.Equals(x, next, System.StringComparison.OrdinalIgnoreCase)).ToList();
                        cycle.Add(next);
                        cycles.Add(cycle);
                    }
                }
            }

            onStack.Remove(node);
            stack.Pop();
        }
    }
}
