// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

using System.Collections.Immutable;
using System.Text.Json.Nodes;
using Azure.Bicep.Types.Concrete;
using System.Text.RegularExpressions;

namespace TemplateSchemaGenerator;

public static class JsonSchemaGenerator
{
    public const string TenantScopeResourceDefinitionsKey = "tenant_resourceDefinitions";
    public const string ManagementGroupScopeResourceDefinitionsKey = "managementGroup_resourceDefinitions";
    public const string SubscriptionScopeResourceDefinitionsKey = "subscription_resourceDefinitions";
    public const string ResourceGroupScopeResourceDefinitionsKey = "resourceDefinitions";
    public const string UnknownScopeResourceDefinitionsKey = "unknown_resourceDefinitions";

    private static readonly ImmutableDictionary<string, ImmutableHashSet<string>> CycleBreakPathsByProviderNamespace =
        new List<(string, string)>
        {
            // Some provider schemas contain circular $ref graphs that break downstream schema normalization.
            // To keep generation resilient while we investigate/fix underlying type modeling issues, we allow
            // targeted cycle breaks keyed by provider namespace + JSON path.
            ("Microsoft.Billing", "definitions.BillingProfileProperties"),
            ("Microsoft.MachineLearning", "definitions.ModuleAssetParameter"),

            ("Microsoft.CostManagement", "definitions.QueryFilter"),
            ("Microsoft.CostManagement", "definitions.QueryFilterAutoGenerated"),
            ("Microsoft.CostManagement", "definitions.ReportConfigFilter"),
            ("Microsoft.CostManagement", "definitions.ReportFilter"),
            ("Microsoft.CostManagement", "definitions.Scope"),

            ("Microsoft.DataFactory", "definitions.ForEachActivityTypeProperties"),
            ("Microsoft.DataFactory", "definitions.IfConditionActivityTypeProperties"),
            ("Microsoft.DataFactory", "definitions.SwitchActivityTypeProperties"),
            ("Microsoft.DataFactory", "definitions.UntilActivityTypeProperties"),

            ("Microsoft.MachineLearning", "definitions.ModeValueInfo"),
            ("Microsoft.MachineLearningServices", "definitions.LabelClass"),
            ("Microsoft.Media", "definitions.JobInput"),

            ("Microsoft.Network", "definitions.ApplicationGatewayBackendAddressPool"),
            ("Microsoft.Network", "definitions.BackendAddressPool"),
            ("Microsoft.Network", "definitions.ContainerNetworkInterface"),
            ("Microsoft.Network", "definitions.CustomIpPrefix"),
            ("Microsoft.Network", "definitions.PublicIPAddress"),
            ("Microsoft.Network", "definitions.ExpressRouteCircuitPeering"),
            ("Microsoft.Network", "definitions.IPConfiguration"),
            ("Microsoft.Network", "definitions.InboundNatRule"),
            ("Microsoft.Network", "definitions.NetworkInterface"),
            ("Microsoft.Network", "definitions.NetworkSecurityGroup"),
            ("Microsoft.Network", "definitions.RouteTable"),
            ("Microsoft.Network", "definitions.VirtualNetworkTap"),
            ("Microsoft.Network", "definitions.CustomIpPrefixPropertiesFormat"),

            ("Microsoft.ProviderHub", "definitions.ExtendedErrorInfo"),

            ("Microsoft.SecurityInsights", "definitions.AutomationRuleCondition"),
            ("Microsoft.SecurityInsights", "definitions.MetadataDependencies"),
            ("Microsoft.SecurityInsights", "definitions.MetadataDependenciesAutoGenerated"),
        }.GroupBy(tuple => tuple.Item1, StringComparer.OrdinalIgnoreCase)
        .ToImmutableDictionary(x => x.Key, x => x.Select(y => y.Item2).ToImmutableHashSet(StringComparer.OrdinalIgnoreCase));

    private static bool ShouldBreakCycle(string providerNamespace, string jsonPath)
        => CycleBreakPathsByProviderNamespace.TryGetValue(providerNamespace, out var paths) && paths.Contains(jsonPath);

    private const string Draft04Schema = "http://json-schema.org/draft-04/schema#";

    private const string ArmExpressionRef = "https://schema.management.azure.com/schemas/common/definitions.json#/definitions/expression";

    public static JsonObject GenerateProviderSchema(string providerNamespace, string apiVersion, IEnumerable<ResourceType> resourceTypes)
    {
        var resourceTypeArray = resourceTypes.ToArray();

        var resourceTypesByName = resourceTypeArray
            .Select(rt => (resourceTypeName: ParseResourceTypeName(rt.Name).resourceTypeName, resourceType: rt))
            .ToDictionary(x => x.resourceTypeName, x => x.resourceType, StringComparer.OrdinalIgnoreCase);

        var resourceTypeNames = resourceTypeArray
            .Select(x => ParseResourceTypeName(x.Name).resourceTypeName)
            .ToImmutableHashSet(StringComparer.OrdinalIgnoreCase);

        var childrenByParentType = resourceTypeNames
            .Select(typeName => typeName.Split('/', StringSplitOptions.RemoveEmptyEntries))
            .Where(parts => parts.Length >= 3) // Provider/type/... (child resources)
            .Select(parts => (
                parent: string.Join('/', parts[..^1]),
                child: string.Join('/', parts)))
            .GroupBy(x => x.parent, StringComparer.OrdinalIgnoreCase)
            .ToDictionary(
                g => g.Key,
                g => g.Select(x => x.child).OrderBy(x => x, StringComparer.OrdinalIgnoreCase).ToArray(),
                StringComparer.OrdinalIgnoreCase);

        var namedTypes = new Dictionary<string, TypeBase>(StringComparer.OrdinalIgnoreCase);
        foreach (var resourceType in resourceTypeArray)
        {
            var (resourceTypeName, _) = ParseResourceTypeName(resourceType.Name);
            foreach (var (name, type) in CollectNamedTypes(resourceType.Body.Type, resourceTypeName))
            {
                // Prefer first occurrence; most definitions are shared.
                // Conflicts are unlikely and generally indicate a naming collision in the source type system.
                namedTypes.TryAdd(name, type);
            }
        }

        var defNames = namedTypes.Keys.ToImmutableHashSet(StringComparer.OrdinalIgnoreCase);
        var converter = new JsonSchemaConverter(defNames);

        var definitionsObject = new JsonObject();
        foreach (var (name, type) in namedTypes.OrderBy(x => x.Key, StringComparer.OrdinalIgnoreCase))
        {
            var jsonPath = $"definitions.{name}";
            if (ShouldBreakCycle(providerNamespace, jsonPath))
            {
                definitionsObject[name] = new JsonObject { ["type"] = "object" };
                continue;
            }

            definitionsObject[name] = converter.ConvertType(type, allowRef: false, []);
        }

        var definitionsByScopeType = new Dictionary<ScopeType, JsonObject>
        {
            [ScopeType.None] = [],
            [ScopeType.ResourceGroup] = [],
            [ScopeType.Subscription] = [],
            [ScopeType.ManagementGroup] = [],
            [ScopeType.Tenant] = [],
        };
        var childResourceDefinitions = new Dictionary<string, JsonObject>(StringComparer.OrdinalIgnoreCase);

        foreach (var resourceType in resourceTypeArray.OrderBy(x => x.Name, StringComparer.OrdinalIgnoreCase))
        {
            var (resourceTypeName, _) = ParseResourceTypeName(resourceType.Name);
            var key = GetArmResourceDefinitionKey(resourceTypeName);

            var resourceDefinition = converter.ConvertResourceDefinition(resourceType, resourceTypeName, apiVersion);
            resourceDefinition["description"] = resourceTypeName;

            if (childrenByParentType.TryGetValue(resourceTypeName, out var children) && children.Length > 0)
            {
                // ARM provider schemas allow nested child resources via a 'resources' array.
                // These child resources use a short-form 'type' (the last path segment).
                var childRefs = new JsonArray();
                foreach (var childTypeName in children)
                {
                    var childKey = GetArmResourceDefinitionKey(childTypeName);
                    var childDefName = childKey + "_childResource";

                    childRefs.Add(new JsonObject
                    {
                        ["$ref"] = "#/definitions/" + childDefName,
                    });

                    if (!childResourceDefinitions.ContainsKey(childDefName))
                    {
                        var childResourceType = resourceTypesByName[childTypeName];
                        var childSchema = converter.ConvertResourceDefinition(childResourceType, childTypeName, apiVersion);
                        childSchema["description"] = childTypeName;

                        var shortType = childTypeName.Split('/', StringSplitOptions.RemoveEmptyEntries).LastOrDefault() ?? childTypeName;
                        if (childSchema["properties"] is JsonObject childProps &&
                            childProps["type"] is JsonObject typeSchema)
                        {
                            typeSchema["enum"] = new JsonArray(shortType);
                        }

                        childResourceDefinitions[childDefName] = childSchema;
                    }
                }

                resourceDefinition["properties"]!["resources"] = new JsonObject
                {
                    ["type"] = "array",
                    ["items"] = new JsonObject
                    {
                        ["oneOf"] = childRefs,
                    },
                };
            }

            foreach (var scopeType in new[] { ScopeType.Tenant, ScopeType.ManagementGroup, ScopeType.Subscription, ScopeType.ResourceGroup, ScopeType.None })
            {
                if (HasWritableScope(resourceType, scopeType))
                {
                    definitionsByScopeType[scopeType][key] = resourceDefinition.DeepClone();
                }
            }
        }

        // Add child resource definitions after all resourceDefinitions have been created.
        if (childResourceDefinitions.Count > 0)
        {
            foreach (var (name, schema) in childResourceDefinitions.OrderBy(x => x.Key, StringComparer.OrdinalIgnoreCase))
            {
                definitionsObject[name] = schema;
            }
        }

        var root = new JsonObject
        {
            ["id"] = $"https://schema.management.azure.com/schemas/{apiVersion}/{providerNamespace}.json#",
            ["title"] = providerNamespace,
            ["description"] = $"{providerNamespace.Replace('.', ' ')} Resource Types",
            ["$schema"] = Draft04Schema,
        };

        foreach (var scopeType in new[] { ScopeType.Tenant, ScopeType.ManagementGroup, ScopeType.Subscription, ScopeType.ResourceGroup, ScopeType.None })
        {
            if (definitionsByScopeType[scopeType].Count > 0)
            {
                root[GetScopeResourceDefinitionsKey(scopeType)] = definitionsByScopeType[scopeType];
            }
        }

        if (definitionsObject.Count > 0)
        {
            root["definitions"] = definitionsObject;
        }

        return root;
    }

    internal static string GetArmResourceDefinitionKey(string resourceTypeName)
    {
        var slashIndex = resourceTypeName.IndexOf('/', StringComparison.Ordinal);
        var unqualifiedTypeName = slashIndex > 0 ? resourceTypeName[(slashIndex + 1)..] : resourceTypeName;

        return SanitizeArmSchemaKey(unqualifiedTypeName);
    }

    private static string SanitizeArmSchemaKey(string value)
        => Regex.Replace(value, "[^a-zA-Z0-9]", "_");

    private static (string resourceTypeName, string apiVersion) ParseResourceTypeName(string name)
    {
        var parts = name.Split('@', 2);
        if (parts.Length != 2)
        {
            throw new InvalidOperationException($"Expected resource type name to contain '@': {name}");
        }

        return (parts[0], parts[1]);
    }

    private static ImmutableDictionary<string, TypeBase> CollectNamedTypes(TypeBase type, string resourceTypeName)
    {
        var referenced = new HashSet<TypeBase>();
        GetReferencedTypes(type, referenced);

        var namedTypes = new Dictionary<string, TypeBase>(StringComparer.OrdinalIgnoreCase);
        foreach (var referencedType in referenced)
        {
            switch (referencedType)
            {
                case ObjectType objectType:
                    namedTypes[objectType.Name] = objectType;
                    break;
                case DiscriminatedObjectType discriminatedObjectType:
                    namedTypes[discriminatedObjectType.Name] = discriminatedObjectType;
                    break;
            }
        }

        // The top-level resource body type is emitted inline at the root.
        // Avoid also emitting it as a named definition.
        namedTypes.Remove(resourceTypeName);

        return namedTypes.ToImmutableDictionary(StringComparer.OrdinalIgnoreCase);
    }

    private static void GetReferencedTypes(TypeBase type, HashSet<TypeBase> types)
    {
        if (types.Contains(type))
        {
            return;
        }

        types.Add(type);

        switch (type)
        {
            case ResourceType resourceType:
                GetReferencedTypes(resourceType.Body.Type, types);
                break;
            case ArrayType arrayType:
                GetReferencedTypes(arrayType.ItemType.Type, types);
                break;
            case ObjectType objectType:
                foreach (var (_, property) in objectType.Properties.OrderBy(x => x.Key, StringComparer.OrdinalIgnoreCase))
                {
                    if (property.Flags.HasFlag(ObjectTypePropertyFlags.ReadOnly))
                    {
                        continue;
                    }

                    GetReferencedTypes(property.Type.Type, types);
                }
                if (objectType.AdditionalProperties is { } addType)
                {
                    GetReferencedTypes(addType.Type, types);
                }
                break;
            case DiscriminatedObjectType discType:
                foreach (var (_, property) in discType.BaseProperties.OrderBy(x => x.Key, StringComparer.OrdinalIgnoreCase))
                {
                    if (property.Flags.HasFlag(ObjectTypePropertyFlags.ReadOnly))
                    {
                        continue;
                    }

                    GetReferencedTypes(property.Type.Type, types);
                }
                foreach (var (_, element) in discType.Elements)
                {
                    GetReferencedTypes(element.Type, types);
                }
                break;
            case UnionType unionType:
                foreach (var member in unionType.Elements)
                {
                    GetReferencedTypes(member.Type, types);
                }
                break;
        }
    }

    public static bool HasWritableScope(ResourceType resourceType, ScopeType targetScope)
        => targetScope switch {
            ScopeType.ResourceGroup => resourceType.WritableScopes.HasFlag(ScopeType.ResourceGroup),
            ScopeType.Subscription => resourceType.WritableScopes.HasFlag(ScopeType.Subscription),
            ScopeType.ManagementGroup => resourceType.WritableScopes.HasFlag(ScopeType.ManagementGroup),
            ScopeType.Tenant => resourceType.WritableScopes.HasFlag(ScopeType.Tenant),
            ScopeType.None => resourceType.WritableScopes == ScopeType.None,
            _ => throw new InvalidOperationException($"Unsupported scope type: {targetScope}"),
        };
    
    public static string GetScopeResourceDefinitionsKey(ScopeType scopeType)
        => scopeType switch {
            ScopeType.Tenant => TenantScopeResourceDefinitionsKey,
            ScopeType.ManagementGroup => ManagementGroupScopeResourceDefinitionsKey,
            ScopeType.Subscription => SubscriptionScopeResourceDefinitionsKey,
            ScopeType.ResourceGroup => ResourceGroupScopeResourceDefinitionsKey,
            ScopeType.None => UnknownScopeResourceDefinitionsKey,
            _ => throw new InvalidOperationException($"Unsupported scope type: {scopeType}"),
        };

    private sealed class JsonSchemaConverter
    {
        private readonly ISet<string> defNames;

        public JsonSchemaConverter(ISet<string> defNames)
        {
            this.defNames = defNames;
        }

        public JsonObject ConvertResourceDefinition(ResourceType resourceType, string resourceTypeName, string apiVersion)
        {
            return resourceType.Body.Type switch
            {
                DiscriminatedObjectType discriminatedBody => ConvertDiscriminatedObjectTypeResourceBody(discriminatedBody, resourceTypeName, apiVersion),
                ObjectType objectBody => ConvertObjectTypeResourceBody(objectBody, resourceTypeName, apiVersion),
                _ => throw new InvalidOperationException($"Unexpected resource body type: {resourceType.Body.Type.GetType().Name}"),
            };
        }

        private JsonObject ConvertObjectTypeResourceBody(ObjectType bodyType, string resourceTypeName, string apiVersion)
        {
            // Always emit ARM resource root properties (apiVersion, name, type).
            // Some Bicep types model "container" resources (with only nested child resources)
            // with a non-ObjectType body. If we return an empty properties bag, downstream
            // schema normalization fails because it cannot read type.enum.
            bodyType.Properties.TryGetValue("name", out var nameProperty);

            // ARM template schemas allow expressions for 'name', and often have resource-specific
            // descriptions. Prefer the source description when it isn't generic; otherwise synthesize
            // a description from the resource type name.
            var nameSchema = nameProperty is not null
                ? ConvertResourcePropertySchema("name", nameProperty.Type.Type, allowRef: true, new HashSet<TypeBase>())
                : new JsonObject { ["type"] = "string" };

            if (nameProperty?.Description is {} nameDescription)
            {
                nameSchema["description"] = nameDescription;
            }

            HashSet<string> excludedProperties = new(StringComparer.OrdinalIgnoreCase) { "name", "type", "apiVersion" };
            var bodyProperties = bodyType.Properties.Where(p =>  !excludedProperties.Contains(p.Key));
            var (properties, required) = ConvertWritableProperties(bodyProperties, []);

            properties.Insert(0, "type", CreateEnumSchema(resourceTypeName));
            properties.Insert(0, "name", nameSchema);
            properties.Insert(0, "apiVersion", CreateEnumSchema(apiVersion));

            required.Insert(0, "type");
            required.Insert(0, "apiVersion");
            required.Insert(0, "name");

            // Some discriminated resources model child-name as a literal. For non-nested form, emit
            // a full-name regex allowing any parent prefix (e.g. ^.*/appsettings$) instead.
            RewriteNameEnumToFullNamePattern(properties);

            // Many resource bodies require 'properties' even when the source type doesn't mark it required.
            EnsureRequiredIfPresent(properties, required, "properties");

            return new JsonObject
            {
                ["type"] = "object",
                ["properties"] = properties,
                ["required"] = required,
            };
        }

        private JsonObject ConvertDiscriminatedObjectTypeResourceBody(DiscriminatedObjectType discriminatedBody, string resourceTypeName, string apiVersion)
        {
            var oneOf = new JsonArray();

            if (discriminatedBody.Elements.Count == 1)
            {
                var element = discriminatedBody.Elements.First().Value;
                if (element.Type is not ObjectType elementObjectType)
                {
                    throw new InvalidOperationException($"Expected discriminated element to be ObjectType, got {element.Type.GetType().Name}");
                }
                
                return ConvertObjectTypeResourceBody(elementObjectType, resourceTypeName, apiVersion);
            }

            foreach (var (_, element) in discriminatedBody.Elements.OrderBy(x => x.Key, StringComparer.OrdinalIgnoreCase))
            {
                if (element.Type is not ObjectType elementObjectType)
                {
                    throw new InvalidOperationException($"Expected discriminated element to be ObjectType, got {element.Type.GetType().Name}");
                }

                HashSet<string> excludedProperties = new(StringComparer.OrdinalIgnoreCase) { "name", "type", "apiVersion" };
                var bodyProperties = discriminatedBody.BaseProperties.Concat(elementObjectType.Properties).Where(p =>  !excludedProperties.Contains(p.Key));
                var (properties, required) = ConvertWritableProperties(bodyProperties, []);

                // Some discriminated resources model child-name as a literal. For non-nested form, emit
                // a full-name regex allowing any parent prefix (e.g. ^.*/appsettings$) instead.
                RewriteNameEnumToFullNamePattern(properties);

                // Many resource bodies require 'properties' even when the source type doesn't mark it required.
                EnsureRequiredIfPresent(properties, required, "properties");

                oneOf.Add(new JsonObject
                {
                    ["type"] = "object",
                    ["properties"] = properties,
                    ["required"] = required,
                });
            }

            var resourceRootProperties = new JsonObject
            {
                ["apiVersion"] = CreateEnumSchema(apiVersion),
                ["type"] = CreateEnumSchema(resourceTypeName),
            };

            return new JsonObject
            {
                ["oneOf"] = oneOf,
                ["properties"] = resourceRootProperties,
                ["required"] = new JsonArray([
                    "apiVersion",
                    "type",
                ]),
            };
        }

        private static void EnsureRequiredIfPresent(JsonObject properties, JsonArray required, string propertyName)
        {
            var hasProperty = properties.Any(kvp => StringComparer.OrdinalIgnoreCase.Equals(kvp.Key, propertyName));
            if (!hasProperty)
            {
                return;
            }

            var alreadyRequired = required.Any(node => node is JsonValue v && StringComparer.OrdinalIgnoreCase.Equals(v.ToString(), propertyName));
            if (!alreadyRequired)
            {
                required.Add(propertyName);
            }
        }

        private static void RewriteNameEnumToFullNamePattern(JsonObject properties)
        {
            var nameEntry = properties.FirstOrDefault(kvp => StringComparer.OrdinalIgnoreCase.Equals(kvp.Key, "name"));
            if (nameEntry.Key is null || nameEntry.Value is not JsonObject nameSchema)
            {
                return;
            }

            if (!nameSchema.TryGetPropertyValue("oneOf", out var oneOfNode) || oneOfNode is not JsonArray oneOfArray || oneOfArray.Count < 1)
            {
                return;
            }

            if (oneOfArray[0] is not JsonObject firstOption)
            {
                return;
            }

            if (!firstOption.TryGetPropertyValue("enum", out var enumNode) || enumNode is not JsonArray enumArray || enumArray.Count != 1)
            {
                return;
            }

            var literal = enumArray[0]?.ToString();
            if (string.IsNullOrWhiteSpace(literal))
            {
                return;
            }

            oneOfArray[0] = new JsonObject
            {
                ["type"] = "string",
                ["pattern"] = $"^.*/{Regex.Escape(literal)}$",
            };
        }

        private JsonObject ConvertResourcePropertySchema(string propertyName, TypeBase type, bool allowRef, HashSet<TypeBase> stack)
            => ConvertPropertySchema(propertyName, type, allowRef, stack, treatTypeAndApiVersionAsStrict: true);

        private JsonObject ConvertPropertySchema(string propertyName, TypeBase type, bool allowRef, HashSet<TypeBase> stack, bool treatTypeAndApiVersionAsStrict)
        {
            var schema = ConvertType(type, allowRef, stack);

            // In ARM template schemas, expressions are represented as strings, but may evaluate to non-string values.
            // Add an expression alternative for non-string schemas, and for constrained strings (e.g. enums),
            // but keep resource identity keys strict.
            if (treatTypeAndApiVersionAsStrict &&
                (StringComparer.OrdinalIgnoreCase.Equals(propertyName, "type") ||
                 StringComparer.OrdinalIgnoreCase.Equals(propertyName, "apiVersion")))
            {
                return schema;
            }

            if (IsPlainStringSchema(schema))
            {
                return schema;
            }

            return OneOfWithExpression(schema);
        }

        private bool TryConvertToDefinitionRef(TypeBase type, out JsonObject? schema)
        {
            if (type is ObjectType objectType && defNames.Contains(objectType.Name))
            {
                schema = RefToDef(objectType.Name);
                return true;
            }

            if (type is DiscriminatedObjectType discType && defNames.Contains(discType.Name))
            {
                schema = RefToDef(discType.Name);
                return true;
            }

            schema = null;
            return false;
        }

        public JsonObject ConvertType(TypeBase type, bool allowRef, HashSet<TypeBase> stack)
        {
            if (!stack.Add(type))
            {
                // recursion guard
                return new JsonObject();
            }

            try
            {
                if (allowRef && TryConvertToDefinitionRef(type, out var definitionRef))
                {
                    return definitionRef!;
                }

                switch (type)
                {
                    case ResourceType resourceType:
                        return ConvertType(resourceType.Body.Type, allowRef, stack);

                    case AnyType:
                        return new JsonObject();

                    case NullType:
                        return new JsonObject { ["type"] = "null" };

                    case BooleanType:
                        return new JsonObject { ["type"] = "boolean" };

                    case IntegerType intType:
                        var intSchema = new JsonObject
                        {
                            ["type"] = "integer",
                        };
                        if (intType.MinValue is {} minValue)
                        {
                            intSchema["minimum"] = minValue;
                        }
                        if (intType.MaxValue is {} maxValue)
                        {
                            intSchema["maximum"] = maxValue;
                        }

                        return intSchema;

                    case StringType stringType:
                        var schema = new JsonObject
                        {
                            ["type"] = "string",
                        };

                        if (stringType.Pattern is {} pattern)
                        {
                            schema["pattern"] = pattern;
                        }

                        if (stringType.MinLength is {} minLength)
                        {
                            schema["minLength"] = minLength;
                        }

                        if (stringType.MaxLength is {} maxLength)
                        {
                            schema["maxLength"] = maxLength;
                        }

                        return schema;

                    case StringLiteralType stringLiteralType:
                        return CreateEnumSchema(stringLiteralType.Value);

                    case ArrayType arrayType:
                        return new JsonObject
                        {
                            ["type"] = "array",
                            ["items"] = ConvertType(arrayType.ItemType.Type, allowRef: true, stack),
                        };

                    case ObjectType objectType:
                        return ConvertObjectType(objectType, stack);

                    case DiscriminatedObjectType discriminatedObjectType:
                        return ConvertDiscriminatedObjectType(discriminatedObjectType, stack);

                    case UnionType unionType:
                        return ConvertUnionType(unionType, stack);

                    default:
                        return new JsonObject();
                }
            }
            finally
            {
                stack.Remove(type);
            }
        }

        private JsonObject ConvertUnionType(UnionType unionType, HashSet<TypeBase> stack)
        {
            var elements = unionType.Elements.Select(x => x.Type).ToArray();

            // Prefer the legacy representation for string-literal unions, even if the union also includes
            // an unconstrained string type (e.g. ('a' | 'b' | ...) | string). Historically we emitted this
            // as a single enum list rather than oneOf of single-value enums.
            if (elements.Length > 0 && elements.All(x => x is StringLiteralType || x is StringType) && elements.Any(x => x is StringLiteralType))
            {
                return CreateEnumSchema([.. elements.OfType<StringLiteralType>().Select(x => x.Value)]);
            }

            var oneOf = new JsonArray();
            foreach (var element in elements)
            {
                oneOf.Add(ConvertType(element, allowRef: true, stack));
            }

            return new JsonObject { ["oneOf"] = oneOf };
        }

        private (JsonObject properties, JsonArray required) ConvertWritableProperties(IEnumerable<KeyValuePair<string, ObjectTypeProperty>> properties, HashSet<TypeBase> stack)
        {
            var propertiesObject = new JsonObject();
            var requiredArray = new JsonArray();

            foreach (var (propName, prop) in properties.OrderBy(x => x.Key, StringComparer.OrdinalIgnoreCase))
            {
                if (prop.Flags.HasFlag(ObjectTypePropertyFlags.ReadOnly))
                {
                    continue;
                }

                var propSchema = ConvertPropertySchema(propName, prop.Type.Type, allowRef: true, stack, treatTypeAndApiVersionAsStrict: false);
                if (!string.IsNullOrWhiteSpace(prop.Description))
                {
                    propSchema["description"] = prop.Description;
                }

                propertiesObject[propName] = propSchema;

                if (prop.Flags.HasFlag(ObjectTypePropertyFlags.Required))
                {
                    requiredArray.Add(propName);
                }
            }

            return (propertiesObject, requiredArray);
        }

        private JsonObject ConvertObjectType(ObjectType objectType, HashSet<TypeBase> stack)
        {
            var (properties, required) = ConvertWritableProperties(objectType.Properties, stack);

            var schema = new JsonObject
            {
                ["type"] = "object",
                ["properties"] = properties,
            };

            if (required.Count > 0)
            {
                schema["required"] = required;
            }

            if (objectType.AdditionalProperties is { } additionalProperties)
            {
                schema["additionalProperties"] = ConvertType(additionalProperties.Type, allowRef: true, stack);
            }

            return schema;
        }

        private JsonObject ConvertDiscriminatedObjectType(DiscriminatedObjectType discType, HashSet<TypeBase> stack)
        {
            var discriminatorValues = discType.Elements.Keys.OrderBy(x => x, StringComparer.OrdinalIgnoreCase).ToArray();

            var (baseProperties, baseRequired) = ConvertWritableProperties(discType.BaseProperties, stack);

            var discriminatorEnum = new JsonArray();
            foreach (var value in discriminatorValues)
            {
                discriminatorEnum.Add(value);
            }

            baseProperties[discType.Discriminator] = new JsonObject
            {
                ["type"] = "string",
                ["enum"] = discriminatorEnum,
            };

            baseRequired.Add(discType.Discriminator);

            var baseSchema = new JsonObject
            {
                ["type"] = "object",
                ["properties"] = baseProperties,
                ["required"] = baseRequired,
                ["additionalProperties"] = false,
            };

            var oneOf = new JsonArray();
            foreach (var (key, element) in discType.Elements.OrderBy(x => x.Key, StringComparer.OrdinalIgnoreCase))
            {
                var elementSchema = ConvertType(element.Type, allowRef: true, stack);

                var discriminatorConstraint = new JsonObject
                {
                    ["type"] = "object",
                    ["properties"] = new JsonObject
                    {
                        [discType.Discriminator] = new JsonObject { ["const"] = key },
                    },
                    ["required"] = new JsonArray(discType.Discriminator),
                };

                oneOf.Add(new JsonObject
                {
                    ["allOf"] = new JsonArray(elementSchema, discriminatorConstraint),
                });
            }

            return new JsonObject
            {
                ["allOf"] = new JsonArray(
                    baseSchema,
                    new JsonObject { ["oneOf"] = oneOf }),
            };
        }

        private static JsonObject RefToDef(string name)
            => new() { ["$ref"] = "#/definitions/" + JsonPointerEscape(name) };

        private static JsonObject ExpressionRef()
            => new() { ["$ref"] = ArmExpressionRef };

        private static JsonObject OneOfWithExpression(JsonObject schema)
            => new() { ["oneOf"] = new JsonArray(schema, ExpressionRef()) };

        private static bool IsPlainStringSchema(JsonObject schema)
        {
            if (schema.TryGetPropertyValue("type", out var typeNode) && typeNode is JsonValue typeValue &&
                string.Equals(typeValue.ToString(), "string", StringComparison.OrdinalIgnoreCase))
            {
                // Constrained strings (enum/pattern/etc.) should allow expression.
                return !schema.ContainsKey("enum") && !schema.ContainsKey("pattern") && !schema.ContainsKey("maxLength") && !schema.ContainsKey("minLength");
            }

            return false;
        }

        private static string JsonPointerEscape(string segment)
            => segment.Replace("~", "~0").Replace("/", "~1");

        private static JsonObject CreateEnumSchema(params string[] values)
            => new()
            {
                ["type"] = "string",
                ["enum"] = new JsonArray(values.Select<string, JsonNode>(x => x).ToArray()),
            };
    }
}