// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

using System.Diagnostics;
using System.IO.Abstractions;
using System.Text.Encodings.Web;
using System.Text.Json;
using Microsoft.WindowsAzure.ResourceStack.Common.Extensions;

namespace TemplateSchemaGenerator;

public class MainGenerator(
    IFileSystem fileSystem,
    ResourceTypeProvider resourceTypeProvider)
{
    public static readonly JsonSerializerOptions SerializerOptions = new()
    {
        WriteIndented = true,
        // Keep output readable (e.g. don't escape apostrophes in descriptions).
        Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping,
    };

    public record Options(string OutputFolder, string? ProviderNamespace);

    private void WriteFile(Options options, string path, string content)
    {
        var filePath = Path.Combine(options.OutputFolder, path);
        fileSystem.Directory.CreateDirectory(Path.GetDirectoryName(filePath)!);
        fileSystem.File.WriteAllText(filePath, content);
    }

    private IEnumerable<GroupedTypes> GetGroupedTypes(Options options)
    {
        var resourceTypesByProvider = resourceTypeProvider.GetResourceTypes()
            .GroupBy(x => Utils.GetProviderNamespace(x.resourceType), StringComparer.OrdinalIgnoreCase);

        foreach (var providerGroup in resourceTypesByProvider)
        {
            var providerNamespace = providerGroup.Key;

            if (options.ProviderNamespace is { } &&
                !StringComparer.OrdinalIgnoreCase.Equals(providerNamespace, options.ProviderNamespace))
            {
                continue;
            }

            var typesByApiVersion = providerGroup
                .GroupBy(x => x.apiVersion, StringComparer.OrdinalIgnoreCase)
                .ToDictionary(x => x.Key, x => x.Select(y => y.resourceType).ToArray(), StringComparer.OrdinalIgnoreCase);

            yield return new(providerNamespace, typesByApiVersion);
        }
    }

    public void Generate(Options options)
    {
        fileSystem.Directory.CreateDirectory(options.OutputFolder);

        // For full generation runs, clear generated content but preserve any hand-authored schemas.
        // For single-provider runs, avoid destructive cleanup to enable iterative workflows.
        if (options.ProviderNamespace is null)
        {
            CleanOutputFolderForFullGeneration(options.OutputFolder);
        }

        var groupedTypes = GetGroupedTypes(options).ToArray();

        var autogeneratedRefs = new List<AutogeneratedResourcesGenerator.ResourceRef>();

        foreach (var grouped in groupedTypes)
        {
            Trace.WriteLine($"Processing {grouped.ProviderNamespace}");

            foreach (var (apiVersion, resourceTypes) in grouped.ResourceTypeByApiVersion)
            {
                var loadedResourceTypes = resourceTypes
                    .Select(typeName => resourceTypeProvider.Get(typeName, apiVersion))
                    .ToArray();

                var schemaPath = $"{apiVersion}/{grouped.ProviderNamespace}.json";
                var schemaContent = JsonSchemaGenerator.GenerateProviderSchema(grouped.ProviderNamespace, apiVersion, loadedResourceTypes);
                WriteFile(options, schemaPath, schemaContent.ToJsonString(SerializerOptions));

                foreach (var resourceType in loadedResourceTypes)
                {
                    var resourceTypeName = resourceType.Name.Split('@', 2)[0];
                    var key = JsonSchemaGenerator.GetArmResourceDefinitionKey(resourceTypeName);

                    autogeneratedRefs.Add(new(apiVersion, grouped.ProviderNamespace, resourceType, key));
                }
            }
        }

        var autogeneratedResources = AutogeneratedResourcesGenerator.Generate([..autogeneratedRefs]);
        WriteFile(options, "common/autogeneratedResources.json", autogeneratedResources.ToJsonString(SerializerOptions));
    }

    private void CleanOutputFolderForFullGeneration(string outputFolder)
    {
        foreach (var filePath in fileSystem.Directory.EnumerateFiles(outputFolder, "*.*", SearchOption.AllDirectories))
        {
            var relativePath = Path.GetRelativePath(outputFolder, filePath).Replace('\\', '/');
            if (ShouldPreserveFile(relativePath))
            {
                continue;
            }

            fileSystem.File.Delete(filePath);
        }
    }

    private static bool ShouldPreserveFile(string filePath)
    {
        var fileName = Path.GetFileName(filePath);
        if (filePath.StartsWith("common/", StringComparison.OrdinalIgnoreCase))
        {
            return true;
        }

        if (fileName.StartsWith("CreateUIDefinition.", StringComparison.OrdinalIgnoreCase) &&
            fileName.EndsWith(".json", StringComparison.OrdinalIgnoreCase))
        {
            return true;
        }

        if (fileName.EndsWith("deploymentTemplate.json", StringComparison.OrdinalIgnoreCase) ||
            fileName.EndsWith("deploymentParameters.json", StringComparison.OrdinalIgnoreCase))
        {
            return true;
        }

        if (fileName.Equals("ViewDefinition.json", StringComparison.OrdinalIgnoreCase) ||
            fileName.Equals("policyDefinition.json", StringComparison.OrdinalIgnoreCase) ||
            fileName.Equals("uiFormDefinition.schema.json", StringComparison.OrdinalIgnoreCase))
        {
            return true;
        }

        return false;
    }

    public record GroupedTypes(
        string ProviderNamespace,
        IReadOnlyDictionary<string, string[]> ResourceTypeByApiVersion);
}
